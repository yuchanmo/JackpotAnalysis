
#참고사항 : 데이터의 주기성등 확인하는 내용  statsmodel
# https://towardsdatascience.com/analyzing-time-series-data-in-pandas-be3887fdd621

# -*- coding: utf-8 -*-
"""월급으로부터 자유롭기

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12_JCBSKfGGuxDJNNnsD837jf7IwxGDT9
"""
# Commented out IPython magic to ensure Python compatibility.
#colab 한글나오게 하기
#https://pinkwink.kr/1255
#%%
#참고사항 : 데이터의 주기성등 확인하는 내용  statsmodel
# https://towardsdatascience.com/analyzing-time-series-data-in-pandas-be3887fdd621

# -*- coding: utf-8 -*-
"""월급으로부터 자유롭기

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12_JCBSKfGGuxDJNNnsD837jf7IwxGDT9
"""
# Commented out IPython magic to ensure Python compatibility.
#colab 한글나오게 하기
#https://pinkwink.kr/1255
#%%

#colab 한글나오게 하기
#https://pinkwink.kr/1255
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_finance import candlestick_ohlc
import pandas as pd 
import numpy as np
from scipy.signal import argrelextrema
import matplotlib.gridspec as gridspec
import datetime
from datetime import datetime
import statsmodels.api as sm
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from multiprocessing import Process, Queue,Pool,Manager
import time
import os
import matplotlib
import matplotlib.font_manager as fm
from matplotlib import rc
import parmap
import multiprocessing
from dbconnector import engine,maria_engine
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)

font_name = fm.FontProperties(fname="c:/Windows/Fonts/malgun.ttf").get_name()
rc('font', family=font_name)


def initializeCodeDf():
  code_df = pd.read_html('http://kind.krx.co.kr/corpgeneral/corpList.do?method=download&searchType=13', header=0)[0] 
  # 종목코드가 6자리이기 때문에 6자리를 맞춰주기 위해 설정해줌 
  code_df.종목코드 = code_df.종목코드.map('{:06d}'.format)
  cols = ['회사명','종목코드','업종','주요제품','상장일','결산월']
  code_df = code_df[cols]
  # 우리가 필요한 것은 회사명과 종목코드이기 때문에 필요없는 column들은 제외해준다. 
  # 한글로된 컬럼명을 영어로 바꿔준다. 
  colname_map = {'회사명':'name','종목코드':'code','업종':'category','주요제품':'products','상장일':'issuedate','결산월':'settlementdate'}
  code_df = code_df.rename(columns=colname_map)   
  return code_df

def getPercent(val):
  return round(val*100,1)


#%%
from sklearn.preprocessing import MinMaxScaler,PolynomialFeatures
from sklearn.pipeline import make_pipeline
from sklearn.metrics import mean_squared_error,r2_score
import numpy as np

def plotCandleChart(df:pd.DataFrame,title:str,showChart:bool=False):      
      fig = plt.figure(figsize=(8, 5))      
      fig.set_facecolor('w')
      gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1])
      axes = []
      axes.append(plt.subplot(gs[0]))
      axes.append(plt.subplot(gs[1], sharex=axes[0]))
      axes[0].get_xaxis().set_visible(False)
      axes[0].set_title(title)
      x = np.arange(len(df.index))
      ohlc = df[['open', 'high', 'low', 'close']].astype(float).values
      dohlc = np.hstack((np.reshape(x, (-1, 1)), ohlc))
      # 봉차트
      candlestick_ohlc(axes[0], dohlc, width=0.5, colorup='r', colordown='b')
      axes[0].plot(x,df['3avg'].astype(float).values)
      # 거래량 차트
      axes[1].bar(x, df.volume, color='k', width=0.6, align='center')
      _xticks = []
      _xlabels = []
      _wd_prev = 0
      for _x, d in zip(x, df.index.values):
          d= pd.to_datetime(str(d))
          weekday = d.weekday()
          if weekday <= _wd_prev:
              _xticks.append(_x)
              _xlabels.append(d.strftime('%Y/%m/%d'))
          _wd_prev = weekday
      axes[1].set_xticks(_xticks)
      axes[1].set_xticklabels(_xlabels, rotation=45, minor=False)
      plt.tight_layout()
      if showChart:
        plt.show()
      return fig

def minusSlope(df,start:str=None,end:str=None):
      reslist = []
      for t in ['3avg','5avg']:
        data = df[start:end][t] if (start ==None) and (end == None) else df
        y = data.values      
        x = np.arange(len(y)).reshape(-1,1)
        model = LinearRegression()
        model.fit(x,y)
        reslist.append(model.coef_)
      reslistarr = np.array(reslist)
      #print(reslistarr) 
      return np.all(reslistarr<0)


def getBestFitModel(df,start:str=None,end:str=None,showplot:bool = False):
      '''
      return 상승중인지?, Fit Score, 가장 잘맞는 Degree는??(1~3차중),Coef
      '''
      data= df[start:end]['close'] if (start ==None) and (end == None) else df
      if showplot:        
        data.plot()  
        plt.title('original trend')
        plt.show()
      y = data.values      
      x = np.arange(len(y))
      score = 0 
      bestdegree = 0
      coef = 0
      
      for i,degree in enumerate([1,2]):
            xx = x.reshape(-1,1)
            yy = y.reshape(-1,1)
            model = make_pipeline(PolynomialFeatures(degree),LinearRegression())
            model.fit(xx,yy)
            py = model.predict(xx).flatten()  
            if showplot:
              plt.title(f'polynormial degree : {degree}')
              plt.scatter(x,y,c='r',label='original')
              plt.scatter(x,py,c='b',label='predict')
              plt.legend(loc='lower left')
              plt.show()
            tcoef = model[1].coef_
            tscore = model.score(xx,yy)
            # print('last coef : ',tcoef[-1],'/ is positive??',tcoef[0][-1]>0)
            # print('model score',tscore)
            if tscore >= score:
                  bestdegree = degree
                  score = tscore
                  coef = tcoef
      
      ascending = coef[0][-1]>0
      return ascending,score,bestdegree,coef




class DailyStockValue():
  code_df = initializeCodeDf()
  url = 'http://finance.naver.com/item/sise_day.nhn?code='
  def __init__(self,name,page_limit:int = 50):
      try:
        row = self.code_df[self.code_df['name']==name].iloc[0]        
        self.row = row    
        self.code = str(row['code'])
        self.name = str(row['name'])
        self.category = str(row['category'])
        self.products = str(row['products'])    
        self.code_url = self.url + self.code
        self.page_limit = page_limit
        self.getMergedData()
      except Exception as e:
        print('없는 종목입니다')
  
  def getMergedData(self):
      new_col_names= {'날짜': 'date', '종가': 'close', '전일비': 'diff', '시가': 'open', '고가': 'high', '저가': 'low', '거래량': 'volume'}
      df = pd.DataFrame()
      for page in range(1,self.page_limit+1):
        pg_url  = f'{self.code_url}&page={page}'
        df = df.append(pd.read_html(pg_url,header=0)[0],ignore_index=True)
      df = df.rename(columns = new_col_names)
      df['date'] = pd.to_datetime(df['date'])
      df = df.set_index('date')
      df = df[df['close'].notnull()]
      df = df.sort_index()   
      #self.lastdate = df.iloc[-1]['date']

      #증감
      diffportion = round(df/df.shift(1)-1,3)*100
      diffportion = diffportion.add_suffix('_diffportion')
      #add rolling (이동평균선)
      rollingdays = [(3,3),(5,3),(20,10),(60,30),(120,20)]
      for r,rm in rollingdays:
        colname = str(r)+'avg'
        df[colname]=df['close'].rolling(r,min_periods=rm).mean()  
      #candle
      df['candlecolor']=np.where(df['close']>=df['open'],'r','b')
      df['volumecolor']=np.where(df['volume']>df.shift(1)['volume'],'r','b')
      df = pd.concat([df,diffportion],axis=1)        
      #지지선 : minpoint / 저항선 : maxpoint
      df['minpoint'] = df.iloc[argrelextrema(df.close.values,np.less_equal)]['close']
      df['maxpoint'] = df.iloc[argrelextrema(df.close.values,np.greater_equal)]['close']
      df['close3avg'] = df['close']/df['3avg']
      df['open_close'] = df['close']-df['open']
      df['open_close_diffportion'] = df['open_close']/df['open']*100
      self.resdf = df
      self.lastdate = df.index[-1].strftime('%Y-%m-%d')
  
  def getAvgMinMaxOfCloseValueBetweenStartAndEnd(self,start,end):
      df = self.resdf
      filtered_df = df[start:end]['close']
      return filtered_df.mean(),filtered_df.min(),filtered_df.max()

  def plotChart(self,fromdate='2020-01-01',todate=datetime.today(),fsize=(10,10)):
      #http://blog.quantylab.com/candlestick.html
      d = self.resdf
      df = d[fromdate:todate]
      plotCandleChart(df,self.name)

  def getCloseValue(self,date):
      return df[date]['close']

  def __repr__(self):
      return f'{self.code}_{self.name}'

  def revertTrend(self):
      recent_data = self.resdf[-10:]      
      today_data = self.resdf.iloc[-1]      
      yesterday_data = self.resdf.iloc[-2]      
      is_minus_slope = minusSlope(recent_data)
      open_close_diff = today_data['open_close_diffportion']
      volum_diff_portion = today_data['volume_diffportion']
      avg_diff_between_y_t = abs((today_data['3avg'] - yesterday_data['3avg'])/today_data['3avg'])*100
      return is_minus_slope and \
             open_close_diff >2.0 and avg_diff_between_y_t<1.5 

  #장대양봉
  #지난5일이상을 덮어버리는 양봉
  def longCandle(self):      
      recent_data = self.resdf[-6:-1]      
      today_data = self.resdf.iloc[-1]            
      is_minus_slope = minusSlope(recent_data)
      recent_max = recent_data['high'].max()
      today_close = today_data['close']      
      volume_diff_portion = today_data['volume_diffportion']      
      return is_minus_slope and  today_close > recent_max and volume_diff_portion > 200                        

  def lowVolumnMeetAvg3(self):
      recent10days = self.resdf[-10:]
      recent3days = self.resdf[-3:]
      days10ascending, score, degree,_ = getBestFitModel(recent10days)
      days3ascending,score,degree,_ = getBestFitModel(recent3days)
      threedaysago =recent10days.iloc[-3]
      twodaysago = recent10days.iloc[-2]
      yesterday = recent10days.iloc[-1]
      predicate = ((float(twodaysago.volume_diffportion)>100.0) and \
                  (float(yesterday.volume_diffportion) <-50.0) and \
                  (float(yesterday.close3avg) <= 1.1) and \
                  (float(twodaysago.close_diffportion)>5) and \
                  (float(yesterday.close_diffportion)>0)) or\
                  ((float(threedaysago.volume_diffportion)>100.0) and \
                  (float(twodaysago.volume_diffportion) <-50.0) and \
                  (float(yesterday.volume_diffportion) <0.0) and \
                  (float(yesterday.close3avg <= 1.1))) and \
                  (float(threedaysago.close_diffportion)>5) and \
                  (float(twodaysago.close_diffportion)>-1) and \
                  (float(yesterday.close_diffportion)>-1) and\
                  (days10ascending) and (days3ascending)
      return predicate

  @classmethod
  def getCodeListWithProduct(cls,product:str)->pd.DataFrame:
      mask = cls.code_df.products.str.contains(product)
      mask = np.where(mask,True,False)
      return cls.code_df[mask]

  @classmethod
  def getCodeListWithName(cls,name:str)->pd.DataFrame:
      mask = cls.code_df.name.str.contains(name)
      mask = np.where(mask,True,False)
      return cls.code_df[mask]

  @classmethod
  def getCodeListWithCategory(cls,category:str)->pd.DataFrame:
      mask = cls.code_df.products.str.contains(product)
      mask = np.where(mask,True,False)
      return cls.code_df[mask]   

  @classmethod
  def getCodeListWithCode(cls,code:str)->pd.DataFrame:
      mask = cls.code_df.code.str.contains(code)
      mask = np.where(mask,True,False)
      return cls.code_df[mask]   

  @property
  def portionComparingBetweenCoronaDurationAndToday(self):    
      avgval,minval,maxval = self.getAvgMinMaxOfCloseValueBetweenStartAndEnd('2020-03-01','2020-03-31')
      todayval = self.resdf.iloc[-1]['close']
      return {'code':self.code,
              'name':self.name,
              'category':self.category,
              'products':self.products,
              'today':todayval,
              'corona_minval':minval,
              'corona_maxval':maxval,
              'today_minval':getPercent(todayval/minval),
              'today_maxval':getPercent(todayval/maxval),
              'min_max':getPercent(minval/maxval)}

# s = DailyStockValue('신풍제약',2)
# s.resdf.index[-1].strftime('%Y-%m-%d')
# s.resdf[-6:-1]['high'].max()
# s.code
# minusSlope(s.resdf[-10:-1])

# s.resdf[-10:-1][['close','open','3avg','minpoint','maxpoint','open_close_diffportion']]
# recent_data = s.resdf[-10:-1]      
# today_data = s.resdf.iloc[-2]      
# yesterday_data = s.resdf.iloc[-3]      
# is_minus_slope = minusSlope(recent_data)
# open_close_diff = today_data['open_close_diffportion']
# volum_diff_portion = today_data['volume_diffportion']
# avg_is_lowest = abs((today_data['3avg'] - yesterday_data['3avg'])/today_data['3avg'])*100
# predicate = is_minus_slope and \
#         open_close_diff >2.0 and \
#         volum_diff_portion > 150.0 and\
#         avg_is_lowest<0 
# reslist = []
# for t in ['3avg','5avg']:
#   data = df[t]
#   y = data.values      
#   x = np.arange(len(y)).reshape(-1,1)
#   model = LinearRegression()
#   model.fit(x,y)
#   reslist.append(model.coef_)
# reslistarr = np.array(reslist)
# np.all(reslistarr<0)

# s.resdf[-5:].iloc[1]

def checkStatus(row,d):      
  rownum,rowval = row  
  name = rowval['name']    
  try:
    stockval = DailyStockValue(name,2)    
    if stockval.lowVolumnMeetAvg3():
      print('added new 폭등 data :',name)
      d['폭등'].append(stockval)
    if stockval.revertTrend():
      print('added new 반전 data :',name)
      d['반전'].append(stockval)
    if stockval.longCandle():
      print('added new 장대 data :',name)
      d['장대'].append(stockval)    
  except Exception as e:
    pass

def saveResultAsPdf(reslist):
  cwd = os.getcwd()  
  #today = list(reslist.values())[0][0].lastdate
  #today = datetime.today().strftime('%Y%m%d')
  # filename = f'shooting_{today}.pdf'
  # path = os.path.join(cwd,'shooting_res',filename)
  # pdf = PdfPages(path)

  # for k,vals in reslist.items():
  #     try:               
  #       for s in vals:
  #         fig = plotCandleChart(s.resdf,f'({k}){s.name}')
  #         pdf.savefig(fig)
  #     except Exception as e:
  #       print(e)        
  # pdf.close()
  
  urlbase = 'https://m.stock.naver.com/item/main.nhn#/stocks/{code}/total'
  for k in reslist.keys():        
    reslist[k] = [(rr.lastdate, rr.name,rr.code,urlbase.replace('{code}',rr.code)) for rr in reslist[k]]
  # reslist['반전'] = [(rr.name,urlbase.replace('{code}',rr.code)) for rr in reslist['반전']]
  # reslist['장대'] = [(rr.name,urlbase.replace('{code}',rr.code)) for rr in reslist['장대']]
  df = pd.DataFrame(columns=['Date','Cate','Name','Code','Url'])
  for k,vals in reslist.items():
      for ld,cn,cd,url in vals:
          linenum = len(df)
          df.loc[linenum] = (ld,k,cn,cd,url)
          
  # df['Date'] = today
  df['Regdate'] = datetime.today()
  df = df[['Date','Cate','Name','Code','Url','Regdate']]
  cols = ['Date','Cate','Name','Code','Url','Regdate']
  join_cols = ['Date','Cate','Name','Code','Url']
  filterdate = df['Date'].iloc[0]
  print(f'query from db for date {filterdate}')
  dbdf = pd.read_sql(f"select * from AriseCodeList where Date='{filterdate}'",engine)
  print('join data')
  merged = pd.merge(df,dbdf,how='left',left_on=join_cols,right_on=join_cols,suffixes=('','_y'))
  print('insert new data')
  rdf = merged[merged['Regdate_y'].isnull()]
  rdf[cols].to_sql('AriseCodeList',engine,if_exists='append',index=False)
  print(f'total {len(rdf)} rows inserted')  

  # txtfilename = f'shooting_{today}.html'
  # txtfilepath = os.path.join(cwd,'shooting_res',txtfilename)

  # html = df.to_html(justify='center')
  # with open(txtfilepath,'w') as f:
  #     f.write(html)
  #open(txtfilepath,'w',encoding='utf-8').write(str(reslist))



if __name__ == '__main__':
  num_cores = multiprocessing.cpu_count()
  code_df = DailyStockValue.code_df
  code_df_list = list(code_df.iterrows())
  manager = Manager()
  l = manager.dict()
  l['폭등'] = manager.list()
  l['반전'] = manager.list()
  l['장대'] = manager.list()
  parmap.map(checkStatus,code_df_list,l,pm_pbar=True,pm_processes=num_cores)
  
  l['폭등'] = list(l['폭등'])
  l['반전'] = list(l['반전'])
  print(l)
  val_cnt = len(np.array(list(l.values())).flatten())
  if val_cnt>0:
    saveResultAsPdf(l)


# import numpy as np
# from itertools import chain
# a={'a':[],'b':[1,2,3]}
# list(chain(list(a.values())))
